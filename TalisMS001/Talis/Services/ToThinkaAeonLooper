<?php


namespace Talis\Services;

/**
 *
 * @author Itay Moav
 *         @date 07-15-2014,07-17-2017
 *        
 *         Define common API and functionality for dataset looper functionality
 *        
 *         Manages the following:
 *        
 *         Filters - clean data retrieved from dataset
 *         QueryFilters - Apply query filters
 *         Dependencies - Remove records which don't pass the dependencies tests
 *         Processing - Support paged asn unpaged proccessing of the result set.
 */
abstract class aAeonLooper {
	const PROCESS_TYPE_NONE    = 2, 
		  PROCESS_TYPE_PROCESS = 3, 
		  PROCESS_TYPE_PAGED   = 5,
		  
		  PAGE 				   = 1,
		  PAGE_SIZE 		   = 100, 
	      PAGE_SIZE_AUTOPAGING = 400,
	      
	      ROW_TYPE__ARRAY  = 'array',
	      ROW_TYPE__OBJECT = 'object'
	;
	
	/**
	 * FOR IMMEDIATE RUN!
	 *
	 * @param unknown $process_type        	
	 * @param array $params        	
	 * @param BL_iDataTransport $Resultset        	
	 * @param unknown $page        	
	 * @param unknown $page_size        	
	 * @return BL_iDataTransport
	 */
	static public function resultSet($process_type, array $params = [], BL_iDataTransport $Resultset = null, $page = self::PAGE, $page_size = self::PAGE_SIZE) {
		return self::create ( $process_type, $params, $Resultset, $page, $page_size )->run ()->getResultset ();
	}
	
	/**
	 * Just create the object, u still need to RUN!
	 *
	 * @param unknown $process_type        	
	 * @param array $params        	
	 * @param BL_iDataTransport $Resultset        	
	 * @param integer $page        	
	 * @param integer $page_size        	
	 * @return aAeonLooper
	 */
	static public function create($process_type, array $params = [], BL_iDataTransport $Resultset = null, $page = self::PAGE, $page_size = self::PAGE_SIZE) {
		return new static ( $process_type, $params, $Resultset, $page, $page_size );
	}
	
	/**
	 * Do before autopaging
	 * 
	 * @param array $params        	
	 */
	static protected function preAutoPaging(array $params = []) {
	}
	
	/**
	 *
	 * @param array $params        	
	 * @param BL_iDataTransport $Resultset        	
	 * @param unknown $page_size        	
	 * @return \Talis\Services\aAeonLooper
	 */
	static public function autoPagingData(array $params = [], BL_iDataTransport $Resultset = null, $page_size = self::PAGE_SIZE_AUTOPAGING): aAeonLooper {
		if (! $Resultset)
			$Resultset = new BL_Set_LokiFake ();
		
		static::preAutoPaging ( $params );
		
		$page = 1;
		$Reader = new static ( self::PROCESS_TYPE_PAGED * self::PROCESS_TYPE_PROCESS, $params, $Resultset, $page, $page_size );
		$Resultset = $Reader->run ()->getResultset ();
		// TODO AEON INCONSISTENCIES: should be getPager() instead -- Holly
		// $num_of_pages = $Resultset->Pager->getTotalPages();
		$num_of_pages = $Resultset->getPager ()->getTotalPages ();
		for($page = 2; $page <= $num_of_pages; $page ++) {
			$Reader = new static ( self::PROCESS_TYPE_PAGED * self::PROCESS_TYPE_PROCESS, $params, $Resultset, $page, $page_size );
			$Reader->run ();
		}
		return $Reader;
	}
	
	/**
	 * As opposed to the query above, here the result set is constantly changing
	 * and getting smaller.
	 * Means the first page, technicaly is always the bnew page.
	 *
	 * @param unknown_type $params        	
	 * @param integer $page_size        	
	 * @return BL_Aeon
	 */
	static public function autoPagingManipulatedData(array $params = [], BL_iDataTransport $Resultset = null, $page_size = self::PAGE_SIZE_AUTOPAGING) {
		if (! $Resultset)
			$Resultset = new BL_Set_LokiFake ();
		
		static::preAutoPaging ( $params );
		
		$Reader = new static ( self::PROCESS_TYPE_PAGED * self::PROCESS_TYPE_PROCESS, $params, $Resultset, 1, $page_size );
		$Resultset = $Reader->run ()->getResultset ();
		// TODO AEON INCONSISTENCIES: should be getPager() instead -- Holly
		// $num_of_pages = ($Resultset->Pager->getTotalPages() -1);//The first page is allready taken care of, and won't be found again.
		$num_of_pages = ($Resultset->getPager ()->getTotalPages () - 1); // The first page is allready taken care of, and won't be found again.
		for($page = 1; $page <= $num_of_pages; $page ++) {
			$Reader = new static ( self::PROCESS_TYPE_PAGED * self::PROCESS_TYPE_PROCESS, $params, $Resultset, 1, $page_size );
			$Reader->run ();
		}
		return $Reader;
	}
	
	/**
	 * The header class, if exists!
	 *
	 * @var BL_Header_Abstract
	 */
	protected $Header = null;
	
	/**
	 *
	 * @var array the $params in the constructor
	 */
	protected $originalParams = [ ];
	
	/**
	 *
	 * @var array params I some time need to process.
	 */
	protected $params = [ ];
	
	/**
	 *
	 * @var array of parameter values to use in sql, this is for the prepared statments
	 */
	protected $paramArray = [ ];
	
	/**
	 * The currntly processed row, this is a by ref assignment
	 *
	 * @var array ref
	 */
	protected $row = [ ];
	
	/**
	 * Is row an array of stdClass,array or something else
	 * Values are defined as consts above.
	 * 
	 * @var string
	 */
	protected $row_type = self::ROW_TYPE__ARRAY;
	
	/**
	 * Pager values
	 */
	protected $page;
	protected $pageSize;
	
	/**
	 * just for auto completion sake
	 *
	 * @var BL_iDataTransport
	 */
	protected $Resultset;
	/**
	 * Mode of processing
	 * 2 - PROCESS_TYPE_NONE
	 * 3 - PROCESS_TYPE_PROCESS
	 * 5 - PROCESS_TYPE_PAGED
	 *
	 * @var integer
	 */
	protected $process_mode = self::PROCESS_TYPE_NONE;
	
	/**
	 * paging values
	 *
	 * @param integer $page        	
	 * @param integer $page_size        	
	 * @return aAeonLooper
	 */
	public function setPaging(int $page, int $page_size):aAeonLooper{
		$this->page     = $page;
		$this->pageSize = $page_size;
		return $this;
	}
	
	/**
	 *
	 * @param string $row_field        	
	 * @return aAeonLooper
	 */
	protected function butcher(string $row_field):aAeonLooper {
		switch($this->row_type){
			case self::ROW_TYPE__ARRAY:
				unset ( $this->row [$row_field] );
				break;
				
			case self::ROW_TYPE__OBJECT:
				unset ( $this->row->$row_field );
				break;
		}
		return $this;
	}
	
	/**
	 * This method should generate string with the query of this dataset.
	 * 
	 * @return mixed resource/query to loop around.
	 */
	abstract protected function query();
	
	/**
	 * @function preInit
	 * Place holder for extra things to do at constructor, should be used
	 * only by abstract classes inheriting this one.
	 *
	 * @return BL_Aeon
	 */
	protected function preInit() {
		return $this;
	}
	
	/**
	 * @function postInit
	 * Place holder for extra things to do at constructor, should be used
	 * only by abstract classes inheriting this one.
	 *
	 * @return BL_Aeon
	 */
	protected function postInit() {
		return $this;
	}
	
	/**
	 * @function process
	 * The default process of a row - override in each report as necessary
	 */
	protected function process() {
		return $this;
	}
	
	/**
	 *
	 * @return BL_Header_Abstract
	 */
	protected function getHeader() {
		$class_name = static::class . 'Header';
		if (! $this->Header && class_exists ( $class_name, false )) {
			$this->Header = new $class_name ();
			$this->Resultset->setHeader ( $this->Header );
		}
		return $this->Header;
	}
	
	/**
	 * @function postProcess
	 * A place holder function (hookup) to be run
	 * logic once the entire processing steps are done.
	 *
	 * @return BL_Aeon
	 */
	protected function postProcess() {
		return $this;
	}
	
	/**
	 * The main entry point to the report generating algorithem
	 *
	 * @return BL_Aeon
	 */
	final public function run() {
		$this->localGenerateResultset ()->postProcess ();
		return $this;
	}
	
	/**
	 * Sets this class data set, this is the default
	 * 
	 * @return aAeonLooper
	 */
	protected function set(\Talis\Message\tLooperMessage $Resultset = null):aAeonLooper {
		$this->Resultset = $Resultset ?: new BL_Set_AsSimpleAsApples ();
		if ($this->Filter)
			$this->Resultset->setFilter ( $this->Filter );
		return $this;
	}
	
	/**
	 *
	 * @return BL_iDataTransport
	 */
	public function getResultset() {
		return $this->Resultset;
	}
	
	/**
	 * Holds the specific structure of the filter for each report object
	 * 
	 * @return @return BL_Filter_Simple
	 */
	public function getFilter() {
		return $this->Filter;
	}
	
	/**
	 * the most commonly used way of localGenerateDataset
	 * Overwrite this if u wish to have different method
	 *
	 * @return BL_Aeon
	 */
	protected function localGenerateResultset() {
		return $this->defaultGenerateResultset ();
	}
	
	
	/**
	 * self explanatory, if u have simple fields in the select, u can use that
	 * to manage the field list in select with the headers
	 */
	protected function extractFieldsFromDS():string {
		$fields = [ ];
		foreach ( $this->Resultset->getHeaders () as $Header ) {
			$fields [] = is_string ( $Header ) ? $Header : $Header->getOrderBy ();
		}
		return join ( ',', $fields );
	}

	/**
	 *
	 * @return aAeonLooper
	 */
	protected function getParam($param_key, $default = null) {
		if (isset ( $this->params [$param_key] )) {
			return $this->params [$param_key];
		}
		return $default;
	}
	
	/**
	 *
	 * @return aAeonLooper
	 */
	protected function setParam($param_key, $param_value) {
		$this->params [$param_key] = $param_value;
		return $this;
	}
	
	/**
	 *
	 * @return aAeonLooper
	 */
	protected function unsetParam($param_key) {
		unset ( $this->params [$param_key] );
		return $this;
	}
} // EOF CLASS






/**
 * Add this if you want a ordered Looper
 */
trait tOrderedAeonLooper{
	protected const ORDER_BY 			= 'order_by', 
					ORDER_BY_DIRECTION  = 'order_by_dir', 
					ORDER_BY_ASC 		= 'asc', 
					ORDER_BY_DESC 		= 'desc'
	;
	
	/**
	 * Default value for the order by clause - overwritten by header
	 *
	 * @var string
	 */
	protected $orderBy = '';
	
	/**
	 * Order by direction - overwritten by header
	 *
	 * @var string
	 */
	protected $orderByDirection = ' ASC ';
	
	/**
	 * set the order by field
	 *
	 * @return aAeonLooper
	 */
	public function setOrderBy(): aAeonLooper {
		$order_by = $this->getParam ( self::ORDER_BY );
		if ($this->getHeader () && $order_by) {
			$this->orderBy = $this->getHeader ()->get_value ( $order_by );
			
			$order_by_dir = $this->getParam ( self::ORDER_BY_DIRECTION );
			if ($order_by_dir) {
				$this->orderByDirection = ($order_by_dir == self::ORDER_BY_DESC) ? self::ORDER_BY_DESC : self::ORDER_BY_ASC;
			}
			
			$this->getHeader ()->setOrderBy ( $order_by, $this->orderByDirection );
		}
		return $this;
	}
	
	/**
	 *
	 * @return string
	 */
	protected function getOrderBySql() {
		if ($this->orderBy) {
			return " ORDER BY {$this->orderBy} {$this->orderByDirection}";
		}
		return '';
	}
	
}